code as a creature

eye:可增量式的运行感知函数，获得结果添加到状态集理
memory:状态集，可有eye和针对状态的hand修正，作为nerve的输入
nerve:从状态集中产生信号，驱动hand的操作
hand:依据相应的触发信号进行相应的操作

本质上，eye是hand的一种特例，或者说所有的本质都是hand，但是nerve和memory分化出来，而eye也特例于本质工作。

Util:底层函数
Body:控制层函数
Brain:策略层函数(更高层次的智能，通过自己的mem，接受nerve产生的低级信号，产生高级信号，并由nerve分解为hand可操作的低级信号)
这样的层次就可以有容纳更聪明的智能的空间了。

如果code的可操作环境包括自身运行的代码，他们甚至可以自适应。自己发现报错，然后处理，废弃掉总是出错的部件，然后利用进化出来的新的部件。我一定是疯了
要实现这些，就需要在细胞层次上重写代码，让这些复杂器官的功能都由无数个细胞协作完成

hand从本质上，应该是一个接口，不同的操作参数在不同的情况下，产生不同的行为。因为本质都是一次点击，以及背后的一次交互。
而所有的复杂行为，都应该从hand中解放出来，充斥到nerve的逻辑里。不是一次调用解决了问题，而是每一次操作都由body的所有部分协作完成。

这样的架构，直接产生了吸引人的一点，只需要更改memory和brain，两者可以从空白到最后的成熟（这是个学习的过程，如果能做成自动的就太美妙了），就可以
接入新的不同的游戏，应付完全不同的世界。对的，这就是一个新的个体。

如果底层也可以通过某种方式自组织，那么这个程序将称为一个虚拟生命，有控制所有二次元的潜力。

信号本身不传递数据，它只包含一个信号，但是收到信号的hand知道该去哪个mem取所需的参数，然后进行哪个操作。这里就有个冲突。所以需要一个中间体。
对信号做静态映射，信号对应操作参数（或者动态参数位于memory的位置）而hand负责执行

当行为逻辑从个体行为均摊到整体后，nerve这部分会庞大起来，线性的遍历会随着系统的复杂而越来越庞大。所以需要一些复用，利用更小部件的交互来产生
大的多种多样的逻辑。

nerve的基元负责监控各个单值的变化（依据相关的域），每个基元逻辑是相同的，只是处理的输入不同。这可以在两个角度实现：空间和时间。对于空间，不同的
基元共存，各自负责各自的监控，而且彼此信息也会相互影响，并引入拓扑关系的复杂度。这个是更合理的，并发也更高，但是当前复杂度难以实现。
另一种时间的方式是，只有一个监控基元，每一次心跳，该基元逻辑遍历所有的监控目标，产生信号集，忽略了彼此之间的影响，但是如果保证每次心跳只产生一次
操作输出，而心跳相对于处理的情况又足够快的话，是可以代替空间实现的。

基元的输入是memory cell， 包含当前值和当前域，以及对应的信号输出结果。输出是sig，包含操作type和优先级value。上层通过产生的sig集合进行选择，挑选一个最优操作进行执行，然后
重复更新数据，重复心跳。

我的本意是构建一个对象，能够对不同的信号做出处理，且重用内部逻辑。可实际上，这样的组织是没有边界的。
仅仅是聚集到一块儿几乎没什么意义。相当于在更低层次的各自分散的元。有利的边界应该是基于管道的高速sig流，
所有此类处理的cell需要聚集到管道周围以快速获取并分发此类消息并处理。这类似于消息的分级传达。这样才能打散人工构造的
较复杂个体，而用简单的个体组构出复杂的行为。

举个例子，构建卡组管理器官的时候，可以分别为每个该器官可能接受的信号编写对应逻辑。每段逻辑处理各自的情况，只是
处理方式相同。但彼此并没有信息交流。而重用的更小个体可以这样组织。有的个体负责信号的接收与加工，有的个体负责
信号的对应执行。但我们的信号是没有分级的。只有人工分级。主消息是group，然后参数是当前状态，或者目的，然后卡组管理器官
自己判断应该做什么，并发送什么样的信号等等。

每个元都只是接收信号，然后依据首参判断行为。一些低级信号只会在有限的元内流转，这也就定义了边界。

/**
 * todo:
 * 重写siguo
 * 
 * 
 */

